if (PCFromEX_){

        // Misprediction detected (Modes iii, iv, v)
        // Is hazard Detection is on , then flush the pipeline
        if (vm_config::config.isHazardDetectionEnabled()) {

            program_counter_ = PCTarget_; // update PC to branch target
            next_if_id_reg = pipelineFetch(); // Fetch from the new PC

            next_id_ex_reg = ID_EX_Register(); // Flush the instruction in ID/EX stage
            stall_cycles_++; // Increment stall cycles

        } else {

            // Mode (ii) - No hazard detection, just update PC
            program_counter_ = PCTarget_; // update PC to branch target
            next_if_id_reg = pipelineFetch(); // Fetch from the new PC

        }

        PCFromEX_ = false; // reset the flag

    } else if(IDPredictTaken_) {

        // Predicted Taken (Mode v)
        // This Code Path is taken when the branch was predicted taken in ID stage and Mode v is active and its not a misprediction
        program_counter_ = IDBranchTarget_; // update PC to branch target
        next_if_id_reg = pipelineFetch(); // Fetch from the new PC

    } else if(id_stall_){
        // Don't Fetch . Freeze the IF_ID register by using its current value
        next_if_id_reg = if_id_reg_;

    }else{
        //No Stall so normal fetch
        next_if_id_reg = pipelineFetch();

        if (!ex_mem_reg_.isControlHarazard/* && !IDPredictTaken_*/){
            //only update pc here if not changing it due to branch/jump
            program_counter_ = next_if_id_reg.pc_plus_4;        
        }

    }




    if (vm_config::config.getBranchPredictionType() == vm_config::BranchPredictionType::STATIC) {
        // Static Branch Prediction: Predict branches as taken
        if (result.isJAL) {
            IDPredictTaken_ = true; // JAL is always predicted taken
            IDBranchTarget_ = result.currentPC + static_cast<int64_t>(result.immediate);
            result.predictedTaken = true;
        } else if (result.isBranch && static_cast<int64_t>(result.immediate) < 0) {
            // Backward branches are predicted taken
            result.predictedTaken = true;
            IDPredictTaken_ = true;
            IDBranchTarget_ = result.currentPC + static_cast<int64_t>(result.immediate);
        }
    } else if (vm_config::config.getBranchPredictionType() == vm_config::BranchPredictionType::DYNAMIC1BIT) {

        if (result.isJAL) {
            // JAL is always predicted taken
            IDPredictTaken_ = true;
            IDBranchTarget_ = result.currentPC + static_cast<int64_t>(result.immediate);
            result.predictedTaken = true;
        } else if (result.isBranch) {
            // Check the Branch History Table for prediction
            if (branch_history_table_.count(result.currentPC) && branch_history_table_[result.currentPC] == true) {
                // Predicted taken
                result.predictedTaken = true;
                IDPredictTaken_ = true;
                IDBranchTarget_ = result.currentPC + static_cast<int64_t>(result.immediate);
            }
        }

    }




    if (vm_config::config.getBranchPredictionType() == vm_config::BranchPredictionType::DYNAMIC1BIT) {
            // Update Branch History Table
            branch_history_table_[id_ex_reg.currentPC] = branchTaken;
        }